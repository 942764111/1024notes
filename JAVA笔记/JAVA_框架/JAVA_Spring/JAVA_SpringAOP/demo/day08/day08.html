<!DOCTYPE html>
<html>
<head>
<title>day08</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>云笔记</h1>
<h2>AOP</h2>
<p>横截面拦截编程</p>
<h3>切入点表达式</h3>
<pre><code>@通知(切入点表达式)
@Around(&quot;bean(userService)&quot;)    
</code></pre>

<p>切入点表达式</p>
<ol>
<li>
<p>类级别</p>
<pre><code>within(cn.tedu.note.service.impl.UserServiceImpl)
within(cn.tedu.note.service.impl.*Impl)
</code></pre>

</li>
<li>
<p>bean对象级别</p>
<pre><code>bean(userService)
bean(userService) || bean(noteService)
bean(*Service) 
</code></pre>

</li>
<li>
<p>方法级别</p>
<pre><code>execution(* cn.tedu.note.service.UserService.login(..))
execution(* cn.tedu.note.service.UserService.*(..))
execution(* cn.tedu.note.service.*Service.*(..))
execution(* cn.tedu.*.service.*Service.*(..))
</code></pre>

</li>
</ol>
<blockquote>
<p>建议: 在软件中将包名，类名，方法名定义的有规律，便于使用“切入点”表达的书写。</p>
</blockquote>
<h3>AOP 的工作原理</h3>
<ol>
<li>注解如何解析：利用反射解析注解</li>
<li>Spring AOP是利用 AspectJ 实现的</li>
<li>
<p>AOP底层利用了动态代理技术</p>
<ul>
<li>如果被代理的位置有接口，则使用JDK动态代理（必须有接口）</li>
<li>如果被代理的位置没有接口，则使用CGLIB动态代理</li>
</ul>
<blockquote>
<p>建议AOP切入到有接口的位置，自动调用JDK动态代理。</p>
</blockquote>
</li>
<li>
<p>JDK动态代理是反射API的一部分</p>
<ul>
<li>java.lang.reflect.Proxy</li>
</ul>
</li>
<li>代理模式：不改变原有类功能，为类的方法扩展功能。</li>
</ol>
<h2>单例模式</h2>
<blockquote>
<p>模式: 	解决特定问题的固定编程套路，是无需思考的固定思路。</p>
</blockquote>
<p>单例模式：解决“单例问题”的固定编程套路。</p>
<p>单例：在程序运行期间类只能有一个实例。</p>
<p>案例：</p>
<pre><code>public class Demo {
    public static void main(String[] args) {
        //Girl friend = new Girl();
        //Girl friend2 = new Girl();
        //Girl g = Girl.girl;
        //Girl.girl = null;
        Girl g = Girl.getGirl();
        Girl g1 = Girl.getGirl();
    }
}
//饿汉式（立即式）
class Girl{
    //....
    private static Girl girl = new Girl();
    private Girl() {
        //...
    }
    public static Girl getGirl() {
        return girl;
    }
}
//懒惰式(懒汉式)
class Boy{
    //....
    private static Boy boy;
    private Boy() {
        //...
    }
    public synchronized static Boy getBoy() {
        if(boy==null){
            boy = new Boy();
        }
        return boy;
    }
}
</code></pre>

<blockquote>
<p>单例，单例模式 区别? </p>
</blockquote>
<p>JDK使用的模式： </p>
<ul>
<li>流：装饰器模式</li>
<li>线程，Servlet： 模板模式</li>
<li>迭代器，ResultSet：迭代器模式</li>
<li>监听器，Swing：观察者模式 </li>
</ul>
<h2>Spring 事物处理</h2>
<p>保证一个业务操作的完整完成，避免其他业务过程的干扰。</p>
<p>编程式事物处理：</p>
<pre><code>//建立连接
conn = ...
try{
    //开始事物                     @Befor
    conn.setAutocomit(false);
    业务操作 过程
    select ...
    insert ... //可能发生异常
    update ... //钱不够，异常
    delete ...
    //提交事物
    conn.commit();                 @AfterReturning
}catch(e){
    //回滚事物 
    conn.rollback();               @AfterThrowing
}finally{
    //释放资源
    conn.close();                  @After
}
</code></pre>

<p>Spring 利用AOP，实现了声明式事物管理： </p>
<pre><code>try{                               //业务方法
    @Befor          //开启事物     @Transactional
    利用反射调用业务方法  --------&gt; updateNote(){....}
    @AfterReturning //提交事物
}catch(e){
    @AfterThrowing  //回滚事物
}finally{
    @After          //释放资源
}
</code></pre>

<p><img src="1.png" /></p>
<p>案例:</p>
<ol>
<li>
<p>配置事务管理器 spring-mybatis.xml:</p>
<pre><code>&lt;!-- 配置事务管理器：基于dataSource的事务管理器 --&gt;
&lt;bean id=&quot;txMgr&quot;            class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 用于驱动 @Transactional 注解 --&gt;
&lt;tx:annotation-driven transaction-manager=&quot;txMgr&quot;/&gt;
</code></pre>

</li>
<li>
<p>持久层方法， NoteDao:</p>
<pre><code>int deleteNote(String id);
</code></pre>

</li>
<li>
<p>添加SQL NoteMapper.xml:</p>
<pre><code>&lt;delete id=&quot;deleteNote&quot;
    parameterType=&quot;string&quot;&gt;
    delete from
        cn_note
    where 
        cn_note_id=#{id}
&lt;/delete&gt;   
</code></pre>

</li>
<li>
<p>业务层方法 NoteService:</p>
<pre><code>int deleteNotes(String... ids);
</code></pre>

</li>
<li>
<p>实现业务层方法</p>
<pre><code>@Transactional
public int deleteNotes(String... ids) {
    //String... 就是 String[] 
    for(String id: ids){
        int n = noteDao.deleteNote(id);
        if(n!=1){
            throw new NoteNotFoundException(id);
        }
    }
    return ids.length;
}
</code></pre>

<blockquote>
<p>业务层方法中使用 @Transactional 这样方法就自动支持事务了，当方法抛出 RuntimeException（含子类）时候，方法中的操作就会自动回滚。
String... 是编程参数，本质上就是字符串数组 String[]	</p>
</blockquote>
</li>
<li>
<p>测试 NoteServiceTestCase：</p>
<pre><code>@Test
public void testDeleteNotes(){
    String id1=&quot;5565bda4-ddee-4f87-844e-2ba83aa4925f&quot;;
    String id2=&quot;9187ffd3-4c1e-4768-9f2f-c600e835b823&quot;;
    String id3=&quot;fed920a0-573c-46c8-ae4e-368397846efd&quot;;
    String id4=&quot;ebd65da6-3f90-45f9-b045-782928a5e2c0&quot;;
    // String... 变长参数，编译过后是 
    // new String[]{id1,id2,id3,id4}
    // String... 只能用于最后一个参数
    int n = service.deleteNotes(
        id1, id2, id3, id4);
    System.out.println(n); 
}
</code></pre>

<blockquote>
<p>测试结果：当传入方法的ID包含错误时候，会发生事务回滚，回退到没有删除的状态，如果传入方法的ID都是正确的时候，方法才能正确执行提交事务删除数据。</p>
</blockquote>
</li>
</ol>
<h3>云笔记事务</h3>
<p>在全部的业务层方法上使用 @Transactional 使项目支持事务。</p>
<h3>事务属性（了解）</h3>
<p>只读属性：@Transactional( readOnly=true ) 说明当前事务方法执行期间只进行数据库读取操作，不对数据库进行写操作（insert, update, delete）使用这个属性可以提供只读方法的性能。</p>
<p>事务隔离属性： </p>
<ul>
<li>isolation=Isolation.DEFAULT</li>
<li>isolation=Isolation.READ_UNCOMMITTED  最低隔离，不推荐</li>
<li>isolation=Isolation.READ_COMMITTED    常见各级基本，就是DEFAULT</li>
<li>isolation=Isolation.REPEATABLE_READ   可以重复读取</li>
<li>isolation=Isolation.SERIALIZABLE      完全串型操作</li>
</ul>
<blockquote>
<p>绝大多数情况下使用默认的 READ_COMMITTED</p>
</blockquote>
<p>事务传播问题：</p>
<p><img src="2.png" /></p>
<p>传播属性:</p>
<ol>
<li>
Propagation.REQUIRED 如果有事务,参与到当前事务, 如果没有就开启新事务. 
<ul>
<li>默认的传播属性,</li>
<li>最常用的属性,</li>
<li>默认值!</li>
</ul>
</li>
<li>Propagation.REQUIRES_NEW, 必须创建新事务, 如果当前有事务, 则当前事务挂起, 开启新事务.</li>
<li>Propagation.NEVER,  绝不, 方法从不参与事务.</li>
<li>Propagation.NESTED, 嵌套, 事务必须嵌套到其他事务中</li>
<li>Propagation.MANDATORY 不能参与事务</li>
<li>Propagation.NOT_SUPPORTED, 不支持, 可以在事务中调用, 但是不参与不支持事务. 调用时候出现异常。</li>
<li>Propagation.SUPPORTS 支持事务, 可以在事务中调用, 但是单独调用, 没有事务保护.</li>
</ol>
<blockquote>
<p>绝大多数使用： REQUIRED</p>
</blockquote>
<h2>MyBatis 复杂SQL问题</h2>
<h3>自增类型Key</h3>
<p>MySQL SQLServer DB2 等数据库提供了自增类型</p>
<p>Oracle 中没有自增类型类型，Oracle提供了类似的Sequence</p>
<p>MySQL：</p>
<pre><code>create table person
(
   person_id int not null auto_increment,
   person_name varchar(50),
   person_age int,
   primary key (person_id)
);
</code></pre>

<p>自增类型会自动填写，无需插入值</p>
<pre><code>insert into person (person_id, person_name, person_age)
    values(null, 'Tom', 10);

insert into person ( person_name, person_age)
    values( 'Tom', 10);
</code></pre>

<p>为什么需要读取自增ID的值：</p>
<p><img src="3.png" /></p>
<p>MyBatis 支持了自增类型：</p>
<ol>
<li>
<p>创建数据库表</p>
<pre><code>create table person
(
   person_id int not null auto_increment,
   person_name varchar(50),
   person_age int,
   primary key (person_id)
);
</code></pre>

</li>
<li>
<p>创建实体类：</p>
<pre><code>public class Person implements Serializable{
    private static final long serialVersionUID = 7033415472221675294L;

    private Integer id;
    private String name;
    private Integer age;

    public Person() {
    }

    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Person [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((id == null) ? 0 : id.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Person other = (Person) obj;
        if (id == null) {
            if (other.id != null)
                return false;
        } else if (!id.equals(other.id))
            return false;
        return true;
    }
}
</code></pre>

</li>
<li>
<p>创建持久层接口:</p>
<p>public interface PersonDao {
	int addPerson(Person person);
}</p>
</li>
<li>
<p>声明SQL， PersonMapper.xml:</p>
<pre><code>&lt;mapper namespace=&quot;cn.tedu.note.dao.PersonDao&quot;&gt;
    &lt;!-- useGeneratedKeys 用于支持自增类型，
    可以在插入数据以后读取自动增加的ID 
    keyProperty=&quot;id&quot; 用于指定那个Bean属性是
    自增类型，Person 类包含属性 ID，属性的值
    会自动的填充为数据库生成的新ID--&gt;
    &lt;insert id=&quot;addPerson&quot;
        useGeneratedKeys=&quot;true&quot;
        parameterType=&quot;cn.tedu.note.entity.Person&quot;
        keyProperty=&quot;id&quot;&gt;
        insert into person(
            person_id,
            person_name,
            person_age
        ) values (
            null,
            #{name},
            #{age}
        )
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>

</li>
<li>
<p>测试 </p>
<pre><code>public class PersonDaoTestCase 
    extends BaseTestCase{

    PersonDao dao;

    @Before
    public void initDao(){
        dao = ctx.getBean(
            &quot;personDao&quot;,PersonDao.class);
    }

    @Test
    public void testAddPerson(){
        Person person = 
            new Person(&quot;李洪鹤&quot;, 30);
        System.out.println(person);//id=null
        //myBatis在添加对象时候，自动的读取自增
        //类型的ID值，填充到person的id属性
        int n = dao.addPerson(person);//id=3
        System.out.println(person); 
        System.out.println(n); 
    }
}
</code></pre>

</li>
</ol>
<h2>MyBatis 动态SQL</h2>
<p>MyBatis 的配置文件支持动态SQL</p>
<ul>
<li><code>&lt;if&gt;</code>  单路分支</li>
<li><code>&lt;choose&gt; &lt;when&gt;</code> 多路分支</li>
<li><code>&lt;trim&gt;</code> 去掉多余的 ， and  or</li>
<li><code>&lt;foreach&gt;</code></li>
</ul>
<blockquote>
<p>如上标签可以与任何的SQL进行拼接</p>
</blockquote>
<p>批量删除可以使用foreach</p>
<pre><code>delete from cn_note where cn_note_id=?
delete from cn_note where cn_note_id=?
delete from cn_note where cn_note_id=?
delete from cn_note where cn_note_id=?
</code></pre>

<p>替换为：</p>
<pre><code>delete from cn_note where cn_note_id in (?,?,?,?)
</code></pre>

<p>利用foreach标签可以生成 如上语句:</p>
<ol>
<li>
<p>声明持久层方法 NoteDao:</p>
<pre><code>int deleteNotes(List&lt;String&gt; list);
</code></pre>

</li>
<li>
<p>声明SQL NoteMapper.xml:</p>
<pre><code>&lt;!-- deleteNotes(List&lt;String&gt; list) --&gt;
&lt;delete id=&quot;deleteNotes&quot;&gt;
    delete from
        cn_note
    where 
        cn_note_id 
    in  
    &lt;foreach collection=&quot;list&quot;
        open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;
        item=&quot;id&quot;&gt;
        #{id}
    &lt;/foreach&gt; 
&lt;/delete&gt;
</code></pre>

</li>
<li>
<p>测试 NoteDaoTestCase</p>
<pre><code>@Test
public void testDeleteNotes(){
    List&lt;String&gt; list=  
        new ArrayList&lt;String&gt;();
    list.add(&quot;84b2d98b-af39-4655-8aa8-d8869d043cca&quot;);
    list.add(&quot;c347f832-e2b2-4cb7-af6f-6710241bcdf6&quot;);
    list.add(&quot;07305c91-d9fa-420d-af09-c3ff209608ff&quot;);
    int n = dao.deleteNotes(list);
    System.out.println(n); 
}
</code></pre>

</li>
</ol>
<p>使用Map封装参数：</p>
<p><img src="4.png" /></p>
<ol>
<li>
<p>声明持久层方法 NoteDao:</p>
<pre><code>int deleteNotesByParams( Map&lt;String, Object&gt; param);
</code></pre>

</li>
<li>
<p>添加SQL NoteMapper.xml:</p>
<pre><code>&lt;!-- 多参数删除, 
    map={statusId=?, idList=list} --&gt;
&lt;delete id=&quot;deleteNotesByParams&quot;
    parameterType=&quot;map&quot;&gt; 
    delete from
        cn_note
    where 
        &lt;if test=&quot;statusId!=null&quot;&gt;
            cn_note_status_id=#{statusId} and 
        &lt;/if&gt;
        cn_note_id in
        &lt;foreach collection=&quot;idList&quot;
            open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;
            item=&quot;id&quot;&gt;
            #{id}
        &lt;/foreach&gt;
&lt;/delete&gt;
</code></pre>

</li>
<li>
<p>测试 NoteDaoTestCase</p>
<pre><code>@Test
public void testDeleteNotesByParams(){
    //组织参数
    Map&lt;String, Object&gt; map=
        new HashMap&lt;String, Object&gt;();
    //添加参数statusId
    map.put(&quot;statusId&quot;, &quot;1&quot;);
    //添加id列表
    List&lt;String&gt; list = 
        new ArrayList&lt;String&gt;();
    list.add(&quot;fsaf-as-df-asdf-as-df-dsa&quot;);
    list.add(&quot;ss19055-30e8-4cdc-bfac-97c6bad9518f&quot;);
    map.put(&quot;idList&quot;, list);
    //调用数据层方法
    int n=dao.deleteNotesByParams(map);
    System.out.println(n);
}
</code></pre>

</li>
</ol>
<p>复杂参数查询：</p>
<p><img src="5.png" /></p>
<ol>
<li>
<p>声明持久层方法 NoteDao.java</p>
<pre><code>List&lt;Map&lt;String, Object&gt;&gt; 
    findNoteByParams(Map&lt;String, Object&gt; param);
</code></pre>

</li>
<li>
<p>声明SQL NoteMapper.xml</p>
<pre><code>&lt;select id=&quot;findNoteByParams&quot;
    parameterType=&quot;map&quot;
    resultType=&quot;map&quot;&gt; 
    select  
        u.cn_user_name as name, 
        n.cn_note_title as title,
        n.cn_note_id  as noteId
    from 
       cn_note n
    left join 
       cn_user u
    on 
       n.cn_user_id = u.cn_user_id  
    &lt;where&gt;
        &lt;trim suffixOverrides=&quot;and&quot;&gt;
            &lt;if test=&quot;name!=null&quot;&gt;
                u.cn_user_name=#{name} and
            &lt;/if&gt;
            &lt;if test=&quot;key!=null&quot;&gt;  
               (n.cn_note_body like '%${key}%' or
               n.cn_note_title like '%${key}%' ) and 
           &lt;/if&gt;
           &lt;if test=&quot;statusId != null&quot;&gt;
            n.cn_note_status_id = #{statusId}
           &lt;/if&gt;
       &lt;/trim&gt;
&lt;/where&gt;
&lt;/select&gt;
</code></pre>

</li>
<li>
<p>测试 NoteDaoTestCase</p>
<pre><code>@Test
public void testFindNotesByParams(){
    Map&lt;String, Object&gt; map =
        new HashMap&lt;String, Object&gt;();

    map.put(&quot;statusId&quot;, &quot;1&quot;);
    map.put(&quot;key&quot;,&quot;a&quot;);
    map.put(&quot;name&quot;, &quot;zhoujia&quot;);

    List&lt;Map&lt;String, Object&gt;&gt; list=
        dao.findNoteByParams(map);
    for (Map&lt;String, Object&gt; obj : list) {
        System.out.println(obj); 
    }
}
</code></pre>

</li>
</ol>
<hr />
<h2>作业</h2>
<ol>
<li>实现复杂参数查询</li>
<li>测试Spring 事务功能</li>
<li>为云笔记增加声明式事务</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
